#!/bin/bash
#
# Created by Yves Blusseau for Bering uClibc
#
# This script is use to store/retrieve files store on a remote git repository
#
# Licensed under the Apace License 2.0
# http://www.apache.org/licenses/LICENSE-2.0.html
#

REMOTE_ANNEX="leaf-storage"
REFS_ANNEX="refs/annex"

HEADER_ANNEX=$(cat <<EOF
#
# THIS FILE IS AUTOGENERATED! DO NOT MODIFY IT!
#
# Hash                                  | File       | Size       | Timestamp
EOF
)

declare -r self="${0##*/}"
declare -r VERSION="1.0"
# Retrieve full path of the command
declare -r CMD=$(readlink "$0" || echo "$0")
# Retrieve full path of the library dir
declare -r LIBRARY_PATH="$(cd "$(dirname "$CMD")" && echo "$PWD")"

. "$LIBRARY_PATH"/utils.lib

# Return the full path from pwd if $path is relative
# else it return $path
_get_abspath_from_pwd() {
    local path="${1:?missing argument}"
    echo $(abspath "$path" "$PWD")
}

# Return the full path from $root_dir if $path is relative
# else it return $path
_get_abspath_from_rootdir() {
    local path="${1:?missing argument}"
    echo $(abspath "$path" "$ROOT_DIR")
}

_get_relative_annex_path_from_pwd() {
    local file="${1:?missing argument}"
    local full_path
    if [[ "$file" =~ ^/ ]]; then
        # Already absolute
        full_path="$file"
    else
        #It's relative
        full_path=$(_get_abspath_from_rootdir "$file")
    fi
    local relative_to_pwd=$(relpath "$full_path" "$PWD")
    echo "$relative_to_pwd"
}

_get_relative_annex_path_from_rootdir() {
    local file="${1:?missing argument}"
    local full_path
    if [[ "$file" =~ ^/ ]]; then
        # Already absolute
        full_path="$file"
    else
        #It's relative
        full_path="$(_get_abspath_from_rootdir "$file")"
    fi
    echo "${full_path/$ROOT_DIR\//}"
}

_escape_ereg() {
    sed 's/[]\.|$(){}?+*^]/\\&/g' <<< "$@"
}

_update_annex_file() {
    local file="${1:?missing argument}"
    local hash=${2:-}
    if [[ -f "$ANNEX" ]]; then
        local ereg="$(_escape_ereg "$file")"
        egrep -v "^#|[A-Fa-f0-9]{40}[|]${ereg}[|]" "$ANNEX" > "$ANNEX"~
    fi
    if [[ -n "$hash" ]]; then
        local size=$(git cat-file -s $hash) || exit $?
        local timestamp=$(date '+%s')
        echo "$hash|$file|$size|$timestamp" >> "$ANNEX"~
    fi
    echo "$HEADER_ANNEX" > "$ANNEX"
    cat "$ANNEX"~ | sort -u -t'|' -k2 >> "$ANNEX"
    rm -f "${ANNEX}"~
}

_update_gitignore_file() {
    local tmp=$(mktemp)
    local header="# begin section managed by $self (do not edit this section by hand)"
    local footer="# end section managed by $self"
    [[ -f "$ANNEX" ]] && egrep -v '^#' "$ANNEX" | cut -d '|' -f2 > "$tmp"
    [[ -f "$ANNEX_INDEX" ]] && sed -nr 's|A[|]([^|]+)[|].*|\1|p' "$ANNEX_INDEX" >> "$tmp"
    sed -i "/$header/,/$footer/d" "$ROOT_DIR/.gitignore"
    echo "$header" >> "$ROOT_DIR/.gitignore"
    sort -u "$tmp" >> "$ROOT_DIR/.gitignore"
    echo "$footer" >> "$ROOT_DIR/.gitignore"
    rm -f "$tmp"
}

_get_hash_from_annex() {
    search_file="${1:?missing argument}"
    if [[ -f "${ANNEX}" ]]; then
        local relfile=$(_get_relative_annex_path_from_rootdir "$search_file")
        local ereg="$(_escape_ereg "$relfile")"
        sed -nr "s|([A-Fa-f0-9]{40})[|]$ereg[|].*|\1|p" "${ANNEX}"
    fi
}

_get_hash_from_annex_index() {
    search_file="${1:?missing argument}"
    if [[ -f "${ANNEX_INDEX}" ]]; then
        local relfile=$(_get_relative_annex_path_from_rootdir "$search_file")
        local ereg="$(_escape_ereg "$relfile")"
        sed -nr "s|^[AD][|]$ereg[|]([A-Fa-f0-9]{40}).*|\1|p" "${ANNEX_INDEX}"
    fi
}

_get_action_from_annex_index() {
    search_file=${1:?missing argument}
    if [[ -f "${ANNEX_INDEX}" ]]; then
        local relfile=$(_get_relative_annex_path_from_rootdir "$search_file")
        local ereg="$(_escape_ereg "$relfile")"
        sed -nr "s|^([AD])[|]$ereg[|].*|\1|p" "${ANNEX_INDEX}"
    fi
}

annex_add() {
    for file in "$@"; do
        if [[ ! -e "$file" ]]; then
            echo "error: the file '$file' doesn't exist !" >&2
            continue
        fi
        if [[ -d "$file" ]]; then
            echo "error: can't add '$file' it's a directory" >&2
            continue
        fi
        # Store the file
        local full=$(_get_abspath_from_pwd "$file")
        local hash=$(git hash-object -t blob -w "$full") || exit $?
        local old_hash=$(_get_hash_from_annex "$full")
        if [[ "$old_hash" != "$hash" ]]; then
            local relfile=$(_get_relative_annex_path_from_rootdir "$full")
            if [[ -f "$ANNEX_INDEX" ]]; then
                local ereg="$(_escape_ereg "$file")"
                egrep -v "^[AD][|]${ereg}[|]" "$ANNEX_INDEX" > "$ANNEX_INDEX"~
            fi
            echo "A|$relfile|$hash" >> "$ANNEX_INDEX"~
            mv "$ANNEX_INDEX"~ "$ANNEX_INDEX"
        fi
    done
    _update_gitignore_file
}

annex_remove() {
    for file in "$@"; do
        local full=$(_get_abspath_from_pwd "$file")
        local hash=""
        if [[ -f "$full" ]]; then
            # Store the file in case so we can restore it
            hash=$(git hash-object -t blob -w "$full") || exit $?
            rm -f "$full"
        fi
        local relfile=$(_get_relative_annex_path_from_rootdir "$full")
        if [[ -f "$ANNEX_INDEX" ]]; then
            local ereg="$(_escape_ereg "$relfile")"
            egrep -v "^[AD][|]${ereg}[|]" "$ANNEX_INDEX" > "$ANNEX_INDEX"~
        fi
        echo "D|$relfile|$hash" >> "$ANNEX_INDEX"~
        mv "$ANNEX_INDEX"~ "$ANNEX_INDEX"
    done
    _update_gitignore_file
}

_annex_store() {
    local hash=${1:?missing argument hash}
    local file=${2:?missing argument file}
    local relfile=$(_get_relative_annex_path_from_rootdir "$file")
    _update_annex_file "$relfile" "$hash" || exit $?
}

_annex_remove_store() {
    local file=${1:?missing argument file}
    local relfile=$(_get_relative_annex_path_from_rootdir "$file")
    _update_annex_file "$relfile" || exit $?
}

annex_commit() {
    if [[ -f "$ANNEX_INDEX" ]]; then
        while IFS='|' read action file hash; do
            case "$action" in
                A) _annex_store $hash "$file";;
                D) _annex_remove_store "$file";;
            esac
        done < <(egrep -v '^#' "$ANNEX_INDEX")
    fi
    rm -f "$ANNEX_INDEX"

    # Add new local references
    while IFS='|' read hash file; do
        git cat-file -e $hash
        [[ $? -ne 0 ]] && continue
        git update-ref "$REFS_ANNEX/$hash" $hash || exit $?
    done < <(egrep -v '^#' "$ANNEX")

    # remove old local references
    while read hash ref; do
        # check if the ref exists in the store
        if [[ $(egrep -c "^$hash[|]" "$ANNEX") -eq 0 ]]; then
            git update-ref -d "$ref" || exit $?
        fi
    done < <(git for-each-ref --format='%(objectname) %(refname)' | egrep "\s$REFS_ANNEX/[A-Fa-f0-9]{40}")
    _update_gitignore_file
}

_do_checkout() {
    local hash=${1:?missing argument hash}
    local full="${2:?missing argument file path}"
    if [[ ! "$full" =~ ^/ ]]; then
        echo "[_do_checkout] error: file path must be absolute !" >&2
        exit 1
    fi
    local path="${full%/*}"
    [[ ! -d "$path" ]] && mkdir -p "$path"

    local local_hash=$(git hash-object "$full" 2>/dev/null)
    git cat-file -e $hash
    local hash_exist=$([[ $? -eq 0 ]] && echo 1 || echo 0)

    # Perhaps the file exists locally
    if [[ "$local_hash" == "$hash" ]]; then
        [[ "$hash_exist" -ne 1 ]] && git hash-object -w "$full" >/dev/null
    else
        if [[ "$hash_exist" -eq 0 ]]; then
            # Try to download from remote
            git fetch -q "$REMOTE_ANNEX" $REFS_ANNEX/$hash:$REFS_ANNEX/$hash || exit 1
        fi
    fi
    git update-ref "$REFS_ANNEX/$hash" $hash
    if [[ "$local_hash" != "$hash" ]]; then
        git show $hash -- > "$full" || exit 1
    fi
}

annex_checkout() {
    local destdir="${1?missing argument destdir}"
    shift;

    local files_to_get=()
    if [[ "$OPT_A" -eq 1 ]]; then
	# Get all files
	if [[ -f "$ANNEX" ]]; then
	   while read file; do
	       files_to_get+=( "$(_get_abspath_from_rootdir "$file")" )
	   done < <(egrep -v '^#' "$ANNEX" | cut -d '|' -f2)
       fi
    else
       files_to_get=("$@")
    fi

    for file in "${files_to_get[@]}"; do
        local full=$(_get_abspath_from_pwd "$file")
        local found=0
        # check if the file is newly delete file
        if [[ -f "${ANNEX_INDEX}" ]]; then
            local hash=$(_get_hash_from_annex_index "$full")
            [[ -n "$hash" ]] && found=1
        fi
        if [[ $found -eq 0 && -f "${ANNEX}" ]]; then
            local hash=$(_get_hash_from_annex "$full")
            [[ -n "$hash" ]] && found=1
        fi
        if [[ $found -eq 1 ]]; then
            local file_path="$full"
            [[ -n "$destdir" ]] && file_path="$(_get_abspath_from_pwd "$destdir/${file##*/}")"
            _do_checkout $hash "$file_path"
        else
            echo "Can't checkout '$file': file not found !" >&2
			exit 33
        fi
    done
}

annex_reset() {
    local file
    for file in "$@"; do
        local full=$(_get_abspath_from_pwd "$file")
        local relfile=$(_get_relative_annex_path_from_rootdir "$full")
        local ereg="$(_escape_ereg "$relfile")"
        sed -i -r "\|^[AD][|]$ereg[|].*|d" "${ANNEX_INDEX}"
    done
    _update_gitignore_file
}

annex_list() {
    local cmd
    if [[ "$OPT_REMOTE" -eq 1 ]]; then
        git fetch -q "$REMOTE_ANNEX" $REFS_ANNEX/all_files:$REFS_ANNEX/all_files
        cmd=("git" "show" "$REFS_ANNEX/all_files")
    else
        [[ ! -f "$ANNEX" ]] && touch "$ANNEX"
        cmd=("egrep" "-v" '^#' "$ANNEX")
    fi
    local now=$(date '+%s')
    local sort_opt=( -k 2 ) # sort by filename
    [[ "$OPT_S" -ne 0 ]] && sort_opt=( -n -k 3 ) # sort by size
    [[ "$OPT_T" -ne 0 ]] && sort_opt=( -n -k 4 ) # sort by date
    [[ "$OPT_R" -ne 0 ]] && sort_opt+=( -r ) # reverse sorting
    local tmp=$(mktemp)
    local total=0
    while IFS='|' read hash file size timestamp; do
        local date='     -     '
        if [[ -n "$timestamp" ]]; then
            local fmt='%b %d %R'
            # timestamp > 1 year
            [[ $(($now - $timestamp)) -gt 31536000 ]] && fmt="%b %d  %Y"
            date=$(date -d @$timestamp "+$fmt")
        fi
        total=$(( $total + $size ))
        printf "%s|%s|%s\n" $(numeric_to_human "$size") "$date" "$(_get_relative_annex_path_from_pwd "$file")"
    done < <(${cmd[*]} | sort -t '|' ${sort_opt[@]}) >"$tmp"
    column -s '|' -t "$tmp"
    printf "Total: %s\n" $(numeric_to_human $total)
}

_status_index_added() {
    local file=${1:?missing argument}
    local hash=${2:?missing argument}
    local text
    local old_hash=$(_get_hash_from_annex "$file")

    if [[ -z "$old_hash" ]]; then
        text=$(_status_added "$file")
    else
        if [[ "$old_hash" != "$hash" ]]; then
            text=$(_status_modified "$file")
        fi
    fi
    [[ -n "$text" ]] && echo "$text"
}

_status_added() {
    local file=${1:?missing argument}
    local relative_file=$(_get_relative_annex_path_from_pwd "$file")
    echo "new file: $relative_file"
}

_status_modified() {
    local file=${1:?missing argument}
    local relative_file=$(_get_relative_annex_path_from_pwd "$file")
    echo "modified: $relative_file"
}

_status_deleted() {
    local file=${1:?missing argument}
    local relative_file=$(_get_relative_annex_path_from_pwd "$file")
    echo "deleted:  $relative_file"
}

annex_status() {
    local text=""
    local msgs=()
    if [[ -f "$ANNEX_INDEX" ]]; then
        while IFS='|' read action file hash; do
            case "$action" in
                A) text=$(_status_index_added "$file" $hash);;
                D) text=$(_status_deleted "$file");;
                *) text="";;
            esac
            [[ -n "$text" ]] && msgs+=("$text")
        done < <(egrep -v '^#' "$ANNEX_INDEX")
        if [[ "${#msgs[@]}" -gt 0 ]]; then
            echo "Changes to be committed:"
            echo "  (use \"$self reset <file>...\" to unstage)"
            for text in "${msgs[@]}"; do
                local color_text=$(say_color yellow "$text")
                printf "\t%s\n" "$(say_color yellow "$text")"
            done
            echo
        fi
    fi

    if [[ -f "$ANNEX" ]]; then
        msgs=()
        while IFS='|' read hash file size; do
            local file_path=$(_get_abspath_from_rootdir "$file")
            local local_hash=$(git hash-object "$file_path" 2>/dev/null)
            local index_hash=$(_get_hash_from_annex_index "$file")
            local index_action=$(_get_action_from_annex_index "$file")
            # Delete case
            if [[ ! -f "$file_path" ]]; then
                [[ "$index_action" == D ]] && continue # Already mark as delete
                msgs+=("$(_status_deleted "$file")")
                continue
            fi
            if [[ "$local_hash" != "$hash" && "$local_hash" != "$index_hash" ]]; then
                msgs+=("$(_status_modified "$file")")
                continue
            fi
        done < <(egrep -v '^#' "$ANNEX")
        if [[ "${#msgs[*]}" -gt 0 ]]; then

            echo 'Changes not staged for commit:'
            echo "  (use \"$self add <file>...\" to update what will be committed)"
            echo "  (use \"$self checkout <file>...\" to discard changes in working directory)"
            echo
            for text in "${msgs[@]}"; do
                printf "\t%s\n" "$(say_color green "$text")"
            done
            echo
        fi
    fi

    # Untracked files
    echo 'Untracked files:'
    echo "  (use \"$self add <file>...\" to include in what will be committed)"
    local file
    while IFS= read -r -u3 file; do
        printf "\t%s\n" "$(say_color cyan "$(_get_relative_annex_path_from_pwd "$file")")"
    done 3< <(git status --untracked-files=normal --porcelain | sed -nr 's|^\?\?\s*(.+)$|\1|p')
}

annex_push() {
    local tmp1=$(mktemp)
    git fetch -q "$REMOTE_ANNEX" $REFS_ANNEX/all_files:$REFS_ANNEX/all_files 1>&2
    if [[ $? -ne 0 ]]; then
        die "Can't get remote files index !"
    fi
    git show $REFS_ANNEX/all_files -- | egrep -v '^#' | sort -u > "$tmp1"

    local tmp2=$(mktemp)
    cat "$ANNEX" | egrep -v '^#' | sort -u > "$tmp2"

    # push new hashs
    while IFS='|' read hash file size; do
        # check if the blob exists locally
        git cat-file -e $hash
        if [[ $? -eq 0 ]]; then
            printf "Pushing %s to %s...\n" "$(say_color cyan $file)" "$(say_color green $REMOTE_ANNEX)"
            git push -q "$REMOTE_ANNEX" $hash:$REFS_ANNEX/$hash || exit $?
        fi
    done < <(comm -1 -3 "$tmp1" "$tmp2")
    # concatenate the local and remote files
    local tmp3=$(mktemp)
    cat "$tmp1" "$tmp2" | egrep -v '^#' | sort -u -t'|' -k2 > "$tmp3"
    rm -f "$tmp1" "$tmp2"
    local hash=$(git hash-object -t blob -w "$tmp3")
    rm -f "$tmp3"
    git push --force -q "$REMOTE_ANNEX" $hash:$REFS_ANNEX/all_files 2>/dev/null || exit $?
    git update-ref "$REFS_ANNEX/all_files" $hash || exit $?
}

annex_cleanup() {
    local tmp1=$(mktemp)
    git for-each-ref --format='%(objectname) %(objecttype) %(refname)' | \
        sed -nr "s|^([A-Fa-f0-9]{40})\s+blob\s+$REFS_ANNEX/[A-Fa-f0-9]{40}$|\1|p" | sort -u >"$tmp1"
    local tmp2=$(mktemp)
    [[ -f "${ANNEX}" ]] && sed -nr "s|^([A-Fa-f0-9]{40})[|].*|\1|p" "${ANNEX}" | sort -u >"$tmp2"

    local hash
    while read hash; do
        git update-ref -d "$REFS_ANNEX/$hash"
    done < <(comm -2 -3 "$tmp1" "$tmp2")

    [[ -f "${ANNEX}" ]] && sed -nr "s|^([A-Fa-f0-9]{40}[|][^|]+[|]).*|\1|p" "${ANNEX}" >"$tmp1"
    git show $REFS_ANNEX/all_files 2>/dev/null | sed -nr "s|^([A-Fa-f0-9]{40}[|][^|]+[|]).*|\1|p" >"$tmp2"
    local file
    while read file; do
        local full="$(_get_abspath_from_rootdir "$file")"
        [[ ! -f "$full" ]] && continue
        local local_hash=$(git hash-object "$full")
        local ereg="$(_escape_ereg "$file")"
        [[ $(egrep -c "^$local_hash[|]$ereg[|]" "$tmp1") -ne 0 ]] && continue
        [[ $(egrep -c "^$local_hash[|]$ereg[|]" "$tmp2") -ne 0 ]] && rm -f "$full"
    done < <( cut -d'|' -f2 "$tmp1" "$tmp2" | sort -u)

    rm -f "$tmp1" "$tmp2"
}


# Print the usage.
usage () {
    printf "Usage: %s ACTION [OPTION] [FILES]\n" "$self"
    echo   "Store/retrieve file(s) from a git repository";
    echo
    print_option_help "-h, --help" "print this message and exit"
    print_option_help "-v, --version" "print the version information and exit"
    echo
    printf   "* Add file(s):\n"
    print_option_help "$self add FILE(s)" "mark the FILE(s) to be added to the local $self repository"
    echo
    printf   "* Delete file(s):\n"
    print_option_help "$self rm FILE(s)" "mark the FILE(s) to be delete from the local $self repository"
    echo
    printf   "* Get file(s):\n"
    print_option_help "$self get [OPTIONS]  FILE(s)" "get FILE(s) from the local or remote $self repository"
    print_option_help "OPTIONS:"
    print_option_help "-d, --directory=DIR" "Checkout the file under the directoy DIR"
    print_option_help "-a, --all"           "Checkout all the files store in local $self repository"
    echo
    printf   "* Reset file(s):\n"
    print_option_help "$self reset FILE(s)" "reset changes to be commit"
    echo
    printf   "* Commit file(s):\n"
    print_option_help "$self commit FILE(s)" "commit the changes to the local $self repository"
    echo
    printf   "* Push file(s):\n"
    print_option_help "$self push" "push the local $self repository to the remote one"
    echo
    printf   "* Status file(s):\n"
    print_option_help "$self status" "Display the status of the files managed by the $self repository"
    echo
    printf   "* List files:\n"
    print_option_help "$self list [OPTIONS]" "list file(s)"
    print_option_help "OPTIONS:"
    print_option_help "--remote" "List ALL the files stored on the remote git repository"
    print_option_help "-r, --reverse-sorting"    "reverse order while sorting"
    print_option_help "-s, --sort-by-size"       "sort file(s) by size"
    print_option_help "-t, --sort-by-time"       "sort file(s) by date"
    echo
    printf   "* Cleanup the $self repository:\n"
    print_option_help "$self cleanup" "remove reference to annex file(s)"
    echo
    echo "Report bugs to <leaf-devel@lists.sourceforge.net>."; echo
}

argument() {
    local opt=$1
    shift
    if [[ $# -eq 0 ]]; then
        printf "%s: option \`%s' requires an argument\n" "$0" "$opt" >&2
        exit 1
    fi
    echo $1
}

# Variables
declare -a ARGS=()
ACTION=""
OPT_REMOTE=0
OPT_A=0
OPT_R=0
OPT_S=0
OPT_T=0

# Check the arguments.
set -e # errexit
while [[ $# -gt 0 ]]; do
    option="$1"
    shift

    case "$option" in
        -h | --help)
                usage
                exit 0 ;;
        -v | --version)
                 echo "$self ${VERSION}"
                 exit 0 ;;
        -d | --directory)
                 CD=$(argument $option "$@"); shift;;
        --directory=*)
                 CD=${option#--directory=};;
        --remote)
                 OPT_REMOTE=1;;
        -a|--all)               OPT_A=1;;
        -r|--reverse-sorting)   OPT_R=1;;
        -s|--sort-by-size)      OPT_S=1;;
        -t|--sort-by-time)      OPT_T=1;;
        -*)
            printf "Unrecognized option \`%s'\n\n" "$option" >&2
            usage
            exit 1
            ;;
        *) ARGS+=("$option") ;; # $ fix fontification
    esac
done
set +e

if [[ ${#ARGS} -eq 0 ]]; then
    printf "Missing parameter(s) !\n";
    usage
fi

ACTION="${ARGS[@]:0:1}";ARGS=( "${ARGS[@]:1}" )

ROOT_DIR=$(git rev-parse --show-toplevel 2>/dev/null)
if [[ $? -ne 0 ]]; then
    echo "fatal: Not a git repository (or any of the parent directories)" >&2
    exit 128
fi
ANNEX="$ROOT_DIR/.$self"
ANNEX_INDEX_DIR=$(git rev-parse --git-dir) || exit $?
[[ ! "$ANNEX_INDEX_DIR" =~ ^/ ]] && ANNEX_INDEX_DIR=$(_get_abspath_from_pwd "$ANNEX_INDEX_DIR")
ANNEX_INDEX="$ANNEX_INDEX_DIR/${self}.idx"

REMOTE_ANNEX_URL="$(git config --get remote.$REMOTE_ANNEX.url)"
if [[ -z "$REMOTE_ANNEX_URL" ]]; then
    git remote add "$REMOTE_ANNEX" 'git://git.code.sf.net/p/leaf/annex'
    git config --unset remote.$REMOTE_ANNEX.fetch
    REMOTE_ANNEX_URL="$(git config --get remote.$REMOTE_ANNEX.url)" || exit 1
fi

set -u # Blow on unbound variable

case "$ACTION" in
    add) annex_add "${ARGS[@]:-}";;
    delete|rm)   annex_remove "${ARGS[@]:-}";;
    checkout|co|get) annex_checkout "${CD:-}" "${ARGS[@]:-}";;
    reset) annex_reset "${ARGS[@]:-}";;
    commit) annex_commit;;
    list|ls) annex_list;;
    status|st) annex_status;;
    push) annex_push;;
    cleanup) annex_cleanup;;
    *) if [[ -z "$ACTION" ]]; then
           printf "You must specified an action !\n" >&2
       else
           printf "Invalid action '$ACTION' !\n" >&2
       fi
       usage;;
esac
