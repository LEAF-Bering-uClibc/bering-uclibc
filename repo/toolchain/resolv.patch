diff --git a/extra/Configs/Config.in b/extra/Configs/Config.in
index eebd154..3e2042a 100644
--- a/extra/Configs/Config.in
+++ b/extra/Configs/Config.in
@@ -1264,6 +1264,16 @@ config UCLIBC_HAS_EXTRA_COMPAT_RES_STATE
 	  Answer Y if selecting UCLIBC_HAS_COMPAT_RES_STATE is not enough.
 	  As far as I can say, this should never be needed.
 
+config UCLIBC_HAS_RESOLVER_SUPPORT
+	bool "DNS resolver functions"
+	select UCLIBC_HAS_COMPAT_RES_STATE
+	help
+	  Provide implementations for DNS resolver functions.
+	  In particular, the following functions will be added to the
+	  library:
+
+	  ns_get16, ns_get32, ns_put16, ns_put32
+
 config UCLIBC_HAS_LIBRESOLV_STUB
 	bool "Provide libresolv stub"
 	help
diff --git a/libc/inet/Makefile.in b/libc/inet/Makefile.in
index d588220..6c2c576 100644
--- a/libc/inet/Makefile.in
+++ b/libc/inet/Makefile.in
@@ -40,6 +40,8 @@ CSRC-$(findstring y,$(UCLIBC_HAS_IPV4)$(UCLIBC_HAS_IPV6)) += \
 CSRC-$(findstring y,$(UCLIBC_HAS_IPV4)$(UCLIBC_HAS_IPV6)) += \
 	res_init.c res_query.c res_comp.c ns_name.c \
 	_res_state.c
+CSRC-$(findstring y,$(UCLIBC_HAS_RESOLVER_SUPPORT)) += \
+	ns_netint.c
 ## # unused ATM
 ## CSRC-y += encodep.c decodep.c formquery.c
 
diff --git a/libc/inet/ns_netint.c b/libc/inet/ns_netint.c
new file mode 100644
index 0000000..acf88dc
--- /dev/null
+++ b/libc/inet/ns_netint.c
@@ -0,0 +1,8 @@
+/*
+ * Copyright (C) 2000-2006 Erik Andersen <andersen at uclibc.org>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#define L_ns_netint
+#include RESOLVER
diff --git a/libc/inet/resolv.c b/libc/inet/resolv.c
index 9f5d118..a347ca5 100644
--- a/libc/inet/resolv.c
+++ b/libc/inet/resolv.c
@@ -3326,6 +3326,32 @@ int res_querydomain(const char *name, const char *domain, int class, int type,
 libc_hidden_def(res_querydomain)
 #endif /* L_res_query */
 
+#ifdef L_ns_netint
+unsigned int ns_get16(const unsigned char *src)
+{
+	unsigned int dst;
+	NS_GET16(dst, src);
+	return dst;
+}
+
+unsigned long ns_get32(const unsigned char *src)
+{
+	unsigned long dst;
+	NS_GET32(dst, src);
+	return dst;
+}
+
+void ns_put16(unsigned int src, unsigned char *dst)
+{
+	NS_PUT16(src, dst);
+}
+
+void ns_put32(unsigned long src, unsigned char *dst)
+{
+	NS_PUT32(src, dst);
+}
+#endif /* L_ns_netint */
+
 /* Unimplemented: */
 /* res_mkquery */
 /* res_send */
diff --git a/include/arpa/nameser.h b/include/arpa/nameser.h
index 917ba19..cdc3df5 100644
--- a/include/arpa/nameser.h
+++ b/include/arpa/nameser.h
@@ -521,6 +521,7 @@ int		ns_name_ntol (const u_char *, u_char *, size_t) __THROW;
 int		ns_name_ntop (const u_char *, char *, size_t) __THROW;
 libc_hidden_proto(ns_name_ntop)
 int		ns_name_pton (const char *, u_char *, size_t) __THROW;
+libc_hidden_proto(ns_name_pton)
 int		ns_name_unpack (const u_char *, const u_char *,
 				const u_char *, u_char *, size_t) __THROW;
 libc_hidden_proto(ns_name_unpack)
diff --git a/libc/inet/resolv.c b/libc/inet/resolv.c
index a347ca5..64e99ba 100644
--- a/libc/inet/resolv.c
+++ b/libc/inet/resolv.c
@@ -339,6 +339,9 @@ Domain name in a message can be represented as either:
 #define BUFSZ       (80) /* one line */
 #define SBUFSIZE    (BUFSZ + 1 + (sizeof(char *) * MAXALIASES))
 
+#define NS_TYPE_ELT					0x40 /*%< EDNS0 extended label type */
+#define DNS_LABELTYPE_BITSTRING		0x41
+
 #undef DEBUG
 /* #define DEBUG */
 
@@ -2792,6 +2795,259 @@ int ns_name_ntop(const u_char *src, char *dst, size_t dstsiz)
 }
 libc_hidden_def(ns_name_ntop)
 
+static const char digits[] = "0123456789";
+
+static const char digitvalue[256] = {
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*16*/
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*32*/
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*48*/
+	 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, /*64*/
+	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*80*/
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*96*/
+	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*112*/
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*128*/
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*256*/
+};
+
+static int encode_bitstring(const char **bp, const char *end,
+							unsigned char **labelp,
+							unsigned char ** dst,
+							unsigned const char *eom)
+{
+	int afterslash = 0;
+	const char *cp = *bp;
+	unsigned char *tp;
+	char c;
+	const char *beg_blen;
+	char *end_blen = NULL;
+	int value = 0, count = 0, tbcount = 0, blen = 0;
+
+	beg_blen = end_blen = NULL;
+
+	/* a bitstring must contain at least 2 characters */
+	if (end - cp < 2)
+		return (EINVAL);
+
+	/* XXX: currently, only hex strings are supported */
+	if (*cp++ != 'x')
+		return (EINVAL);
+	if (!isxdigit((*cp) & 0xff)) /*%< reject '\[x/BLEN]' */
+		return (EINVAL);
+
+	for (tp = *dst + 1; cp < end && tp < eom; cp++) {
+		switch((c = *cp)) {
+		case ']':       /*%< end of the bitstring */
+			if (afterslash) {
+				if (beg_blen == NULL)
+					return (EINVAL);
+				blen = (int)strtol(beg_blen, &end_blen, 10);
+				if (*end_blen != ']')
+					return (EINVAL);
+			}
+			if (count)
+				*tp++ = ((value << 4) & 0xff);
+			cp++;   /*%< skip ']' */
+			goto done;
+		case '/':
+			afterslash = 1;
+			break;
+		default:
+			if (afterslash) {
+				if (!isdigit(c&0xff))
+					return (EINVAL);
+				if (beg_blen == NULL) {
+
+					if (c == '0') {
+						/* blen never begings with 0 */
+						return (EINVAL);
+					}
+					beg_blen = cp;
+				}
+			} else {
+				if (!isxdigit(c&0xff))
+					return (EINVAL);
+				value <<= 4;
+				value += digitvalue[(int)c];
+				count += 4;
+				tbcount += 4;
+				if (tbcount > 256)
+					return (EINVAL);
+				if (count == 8) {
+					*tp++ = value;
+					count = 0;
+				}
+			}
+			break;
+		}
+	}
+  done:
+	if (cp >= end || tp >= eom)
+		return (EMSGSIZE);
+
+	/*
+	 * bit length validation:
+	 * If a <length> is present, the number of digits in the <bit-data>
+	 * MUST be just sufficient to contain the number of bits specified
+	 * by the <length>. If there are insignificant bits in a final
+	 * hexadecimal or octal digit, they MUST be zero.
+	 * RFC2673, Section 3.2.
+	 */
+	if (blen > 0) {
+		int traillen;
+
+		if (((blen + 3) & ~3) != tbcount)
+			return (EINVAL);
+		traillen = tbcount - blen; /*%< between 0 and 3 */
+		if (((value << (8 - traillen)) & 0xff) != 0)
+			return (EINVAL);
+	}
+	else
+		blen = tbcount;
+	if (blen == 256)
+		blen = 0;
+
+	/* encode the type and the significant bit fields */
+	**labelp = DNS_LABELTYPE_BITSTRING;
+	**dst = blen;
+
+	*bp = cp;
+	*dst = tp;
+
+	return (0);
+}
+
+int ns_name_pton(const char *src, u_char *dst, size_t dstsiz)
+{
+	u_char *label, *bp, *eom;
+	int c, n, escaped, e = 0;
+	char *cp;
+
+	escaped = 0;
+	bp = dst;
+	eom = dst + dstsiz;
+	label = bp++;
+
+	while ((c = *src++) != 0) {
+		if (escaped) {
+			if (c == '[') { /*%< start a bit string label */
+				if ((cp = strchr(src, ']')) == NULL) {
+					errno = EINVAL; /*%< ??? */
+					return (-1);
+				}
+				if ((e = encode_bitstring(&src, cp + 2,
+							 &label, &bp, eom))
+				    != 0) {
+					errno = e;
+					return (-1);
+				}
+				escaped = 0;
+				label = bp++;
+				if ((c = *src++) == 0)
+					goto done;
+				else if (c != '.') {
+					errno = EINVAL;
+					return  (-1);
+				}
+				continue;
+			}
+			else if ((cp = strchr(digits, c)) != NULL) {
+				n = (cp - digits) * 100;
+				if ((c = *src++) == 0 ||
+				    (cp = strchr(digits, c)) == NULL) {
+					errno = EMSGSIZE;
+					return (-1);
+				}
+				n += (cp - digits) * 10;
+				if ((c = *src++) == 0 ||
+				    (cp = strchr(digits, c)) == NULL) {
+					errno = EMSGSIZE;
+					return (-1);
+				}
+				n += (cp - digits);
+				if (n > 255) {
+					errno = EMSGSIZE;
+					return (-1);
+				}
+				c = n;
+			}
+			escaped = 0;
+		} else if (c == '\\') {
+			escaped = 1;
+			continue;
+		} else if (c == '.') {
+			c = (bp - label - 1);
+			if ((c & NS_CMPRSFLGS) != 0) {  /*%< Label too big. */
+				errno = EMSGSIZE;
+				return (-1);
+			}
+			if (label >= eom) {
+				errno = EMSGSIZE;
+				return (-1);
+			}
+			*label = c;
+			/* Fully qualified ? */
+			if (*src == '\0') {
+				if (c != 0) {
+					if (bp >= eom) {
+						errno = EMSGSIZE;
+						return (-1);
+					}
+					*bp++ = '\0';
+				}
+				if ((bp - dst) > MAXCDNAME) {
+					errno = EMSGSIZE;
+					return (-1);
+				}
+
+				return (1);
+			}
+			if (c == 0 || *src == '.') {
+				errno = EMSGSIZE;
+				return (-1);
+			}
+			label = bp++;
+			continue;
+		}
+		if (bp >= eom) {
+			errno = EMSGSIZE;
+			return (-1);
+		}
+		*bp++ = (u_char)c;
+	}
+	c = (bp - label - 1);
+	if ((c & NS_CMPRSFLGS) != 0) {	  /*%< Label too big. */
+		errno = EMSGSIZE;
+		return (-1);
+	}
+  done:
+	if (label >= eom) {
+		errno = EMSGSIZE;
+		return (-1);
+	}
+	*label = c;
+	if (c != 0) {
+		if (bp >= eom) {
+			errno = EMSGSIZE;
+			return (-1);
+		}
+		*bp++ = 0;
+	}
+	if ((bp - dst) > MAXCDNAME) {   /*%< src too big */
+		errno = EMSGSIZE;
+		return (-1);
+	}
+
+	return (0);
+}
+libc_hidden_def(ns_name_pton)
+
 /*
  * ns_name_unpack(msg, eom, src, dst, dstsiz)
  *      Unpack a domain name from a message, source may be compressed.
@@ -2866,6 +3122,218 @@ int ns_name_unpack(const u_char *msg, const u_char *eom, const u_char *src,
 	return len;
 }
 libc_hidden_def(ns_name_unpack)
+
+static int labellen(const unsigned char *lp)
+{
+	int bitlen;
+	unsigned char l = *lp;
+
+	if ((l & NS_CMPRSFLGS) == NS_CMPRSFLGS) {
+		/* should be avoided by the caller */
+		return -1;
+	}
+
+	if ((l & NS_CMPRSFLGS) == NS_TYPE_ELT) {
+		if (l == DNS_LABELTYPE_BITSTRING) {
+			if ((bitlen = *(lp + 1)) == 0)
+				bitlen = 256;
+			return ((bitlen + 7 ) / 8 + 1);
+		}
+
+		return -1;    /*%< unknwon ELT */
+	}
+
+	return l;
+}
+
+static int mklower(int ch)
+{
+	if (ch >= 0x41 && ch <= 0x5A)
+		return (ch + 0x20);
+
+	return (ch);
+}
+
+static int dn_find(const unsigned char *domain,
+				   const unsigned char *msg,
+				   const unsigned char * const *dnptrs,
+				   const unsigned char * const *lastdnptr)
+{
+	const unsigned char *dn, *cp, *sp;
+	const unsigned char * const *cpp;
+	u_int n;
+
+	for (cpp = dnptrs; cpp < lastdnptr; cpp++) {
+		sp = *cpp;
+		/*
+		 * terminate search on:
+		 * root label
+		 * compression pointer
+		 * unusable offset
+		 */
+		while (*sp != 0 && (*sp & NS_CMPRSFLGS) == 0 &&
+				(sp - msg) < 0x4000) {
+			dn = domain;
+			cp = sp;
+
+			while ((n = *cp++) != 0) {
+				/*
+				 * check for indirection
+				 */
+				switch (n & NS_CMPRSFLGS) {
+				case 0:	 /*%< normal case, n == len */
+					n = labellen(cp - 1); /*%< XXX */
+					if (n != *dn++)
+						goto next;
+
+					for (; n > 0; n--)
+						if (mklower(*dn++) !=
+						    mklower(*cp++))
+							goto next;
+					/* Is next root for both ? */
+					if (*dn == '\0' && *cp == '\0')
+						return (sp - msg);
+					if (*dn)
+						continue;
+					goto next;
+				case NS_CMPRSFLGS:      /*%< indirection */
+					cp = msg + (((n & 0x3f) << 8) | *cp);
+					break;
+
+				default:	/*%< illegal type */
+					errno = EMSGSIZE;
+					return -1;
+				}
+			}
+next:
+			sp += *sp + 1;
+		}
+	}
+
+	errno = ENOENT;
+	return -1;
+}
+
+int ns_name_pack(const unsigned char *src,
+				 unsigned char *dst, int dstsiz,
+				 const unsigned char **dnptrs,
+				 const unsigned char **lastdnptr)
+{
+	unsigned char *dstp;
+	const unsigned char **cpp, **lpp, *eob, *msg;
+	const unsigned char *srcp;
+	int n, l, first = 1;
+
+	srcp = src;
+	dstp = dst;
+	eob = dstp + dstsiz;
+	lpp = cpp = NULL;
+
+	if (dnptrs != NULL) {
+		if ((msg = *dnptrs++) != NULL) {
+			for (cpp = dnptrs; *cpp != NULL; cpp++)
+				continue;
+
+			lpp = cpp;      /*%< end of list to search */
+		}
+	} else {
+		msg = NULL;
+	}
+
+	/* make sure the domain we are about to add is legal */
+	l = 0;
+	do {
+		int l0;
+
+		n = *srcp;
+		if ((n & NS_CMPRSFLGS) == NS_CMPRSFLGS) {
+			errno = EMSGSIZE;
+			return -1;
+		}
+
+		if ((l0 = labellen(srcp)) < 0) {
+			errno = EINVAL;
+			return -1;
+		}
+
+		l += l0 + 1;
+		if (l > MAXCDNAME) {
+			errno = EMSGSIZE;
+			return -1;
+		}
+
+		srcp += l0 + 1;
+	} while (n != 0);
+
+	/* from here on we need to reset compression pointer array on error */
+	srcp = src;
+
+	do {
+		/* Look to see if we can use pointers. */
+		n = *srcp;
+
+		if (n != 0 && msg != NULL) {
+			l = dn_find(srcp, msg, (const unsigned char * const *) dnptrs,
+						(const unsigned char * const *) lpp);
+			if (l >= 0) {
+				if (dstp + 1 >= eob) {
+					goto cleanup;
+				}
+
+				*dstp++ = ((u_int32_t)l >> 8) | NS_CMPRSFLGS;
+				*dstp++ = l % 256;
+				return (dstp - dst);
+			}
+
+			/* Not found, save it. */
+			if (lastdnptr != NULL && cpp < lastdnptr - 1 &&
+				(dstp - msg) < 0x4000 && first) {
+				*cpp++ = dstp;
+				*cpp = NULL;
+				first = 0;
+			}
+		}
+
+		/* copy label to buffer */
+		if ((n & NS_CMPRSFLGS) == NS_CMPRSFLGS) {
+			/* Should not happen. */
+			goto cleanup;
+		}
+
+		n = labellen(srcp);
+		if (dstp + 1 + n >= eob) {
+			goto cleanup;
+		}
+
+		memcpy(dstp, srcp, (size_t)(n + 1));
+		srcp += n + 1;
+		dstp += n + 1;
+	} while (n != 0);
+
+	if (dstp > eob) {
+cleanup:
+		if (msg != NULL)
+			*lpp = NULL;
+
+			errno = EMSGSIZE;
+			return -1;
+	}
+
+	return dstp - dst;
+}
+
+int ns_name_compress(const char *src,
+					 unsigned char *dst, size_t dstsiz,
+					 const unsigned char **dnptrs,
+					 const unsigned char **lastdnptr)
+{
+	unsigned char tmp[NS_MAXCDNAME];
+
+	if (ns_name_pton(src, tmp, sizeof(tmp)) == -1)
+		return -1;
+
+	return ns_name_pack(tmp, dst, dstsiz, dnptrs, lastdnptr);
+}
 #endif /* L_ns_name */
 
 

diff --git a/include/resolv.h b/include/resolv.h
index cba26f0..0afb375 100644
--- a/include/resolv.h
+++ b/include/resolv.h
@@ -332,9 +332,9 @@ __END_DECLS
 #if 0
 #define b64_ntop		__b64_ntop
 #define b64_pton		__b64_pton
-#define dn_comp			__dn_comp
 #define dn_count_labels		__dn_count_labels
 #endif
+#define dn_comp			__dn_comp
 #define dn_expand		__dn_expand
 #if 0
 #define dn_skipname		__dn_skipname
@@ -404,9 +404,9 @@ const u_char *	p_fqname (const u_char *, const u_char *, FILE *) __THROW;
 const char *	p_option (u_long option) __THROW;
 char *		p_secstodate (u_long) __THROW;
 int		dn_count_labels (const char *) __THROW;
+#endif
 int		dn_comp (const char *, u_char *, int, u_char **, u_char **)
      __THROW;
-#endif
 int		dn_expand (const u_char *, const u_char *, const u_char *,
 			   char *, int) __THROW;
 #if 0
diff --git a/libc/inet/resolv.c b/libc/inet/resolv.c
index 64e99ba..a74ab30 100644
--- a/libc/inet/resolv.c
+++ b/libc/inet/resolv.c
@@ -2659,6 +2659,20 @@ int dn_expand(const u_char *msg, const u_char *eom, const u_char *src,
 		dst[0] = '\0';
 	return n;
 }
+
+/*
+ * Pack domain name 'exp_dn' in presentation form into 'comp_dn'.
+ * Return the size of the compressed name or -1.
+ * 'length' is the size of the array pointed to by 'comp_dn'.
+ */
+int
+dn_comp(const char *src, u_char *dst, int dstsiz,
+		u_char **dnptrs, u_char **lastdnptr)
+{
+	return ns_name_compress(src, dst, (size_t) dstsiz,
+			(const u_char **) dnptrs,
+			(const u_char **) lastdnptr);
+}
 #endif /* L_res_comp */
 
 
@@ -3823,4 +3837,3 @@ void ns_put32(unsigned long src, unsigned char *dst)
 /* Unimplemented: */
 /* res_mkquery */
 /* res_send */
-/* dn_comp */
diff --git a/include/resolv.h b/include/resolv.h
index 0afb375..6556365 100644
--- a/include/resolv.h
+++ b/include/resolv.h
@@ -336,8 +336,8 @@ __END_DECLS
 #endif
 #define dn_comp			__dn_comp
 #define dn_expand		__dn_expand
-#if 0
 #define dn_skipname		__dn_skipname
+#if 0
 #define fp_resstat		__fp_resstat
 #define loc_aton		__loc_aton
 #define loc_ntoa		__loc_ntoa
@@ -388,7 +388,6 @@ int		b64_ntop (u_char const *, size_t, char *, size_t) __THROW;
 int		b64_pton (char const *, u_char *, size_t) __THROW;
 int		loc_aton (const char *ascii, u_char *binary) __THROW;
 const char *	loc_ntoa (const u_char *binary, char *ascii) __THROW;
-int		dn_skipname (const u_char *, const u_char *) __THROW;
 void		putlong (u_int32_t, u_char *) __THROW;
 void		putshort (u_int16_t, u_char *) __THROW;
 const char *	p_class (int) __THROW;
@@ -405,6 +404,7 @@ const char *	p_option (u_long option) __THROW;
 char *		p_secstodate (u_long) __THROW;
 int		dn_count_labels (const char *) __THROW;
 #endif
+int		dn_skipname (const u_char *, const u_char *) __THROW;
 int		dn_comp (const char *, u_char *, int, u_char **, u_char **)
      __THROW;
 int		dn_expand (const u_char *, const u_char *, const u_char *,
diff --git a/libc/inet/resolv.c b/libc/inet/resolv.c
index a74ab30..6bfe52c 100644
--- a/libc/inet/resolv.c
+++ b/libc/inet/resolv.c
@@ -3348,6 +3348,58 @@ int ns_name_compress(const char *src,
 
 	return ns_name_pack(tmp, dst, dstsiz, dnptrs, lastdnptr);
 }
+
+int ns_name_skip(const unsigned char **ptrptr,
+				 const unsigned char *eom)
+{
+	const unsigned char *cp;
+	u_int n;
+	int l;
+
+	cp = *ptrptr;
+	while (cp < eom && (n = *cp++) != 0) {
+		/* Check for indirection. */
+		switch (n & NS_CMPRSFLGS) {
+		case 0:		 /*%< normal case, n == len */
+			cp += n;
+			continue;
+		case NS_TYPE_ELT: /*%< EDNS0 extended label */
+			if ((l = labellen(cp - 1)) < 0) {
+				errno = EMSGSIZE; /*%< XXX */
+				return -1;
+			}
+			cp += l;
+			continue;
+		case NS_CMPRSFLGS:      /*%< indirection */
+			cp++;
+			break;
+		default:		/*%< illegal type */
+			errno = EMSGSIZE;
+			return -1;
+		}
+
+		break;
+	}
+
+	if (cp > eom) {
+		errno = EMSGSIZE;
+		return -1;
+	}
+
+	*ptrptr = cp;
+
+	return 0;
+}
+
+int dn_skipname(const unsigned char *ptr, const unsigned char *eom)
+{
+	const unsigned char *saveptr = ptr;
+
+	if (ns_name_skip(&ptr, eom) == -1)
+		return -1;
+
+	return ptr - saveptr;
+}
 #endif /* L_ns_name */
 
 
diff --git a/include/arpa/nameser.h b/include/arpa/nameser.h
index cdc3df5..1534249 100644
--- a/include/arpa/nameser.h
+++ b/include/arpa/nameser.h
@@ -120,13 +120,9 @@ typedef struct __ns_msg {
 
 /* Private data structure - do not use from outside library. */
 struct _ns_flagdata {  int mask, shift;  };
-extern struct _ns_flagdata _ns_flagdata[];
+extern const struct _ns_flagdata _ns_flagdata[];
 
 /* Accessor macros - this is part of the public interface. */
-#define ns_msg_getflag(handle, flag) ( \
-			((handle)._flags & _ns_flagdata[flag].mask) \
-			 >> _ns_flagdata[flag].shift \
-			)
 #define ns_msg_id(handle) ((handle)._id + 0)
 #define ns_msg_base(handle) ((handle)._msg + 0)
 #define ns_msg_end(handle) ((handle)._eom + 0)
@@ -499,6 +495,7 @@ typedef enum __ns_cert_types {
 #define	ns_samename		__ns_samename
 
 __BEGIN_DECLS
+int			ns_msg_getflag (ns_msg, int) __THROW;
 u_int		ns_get16 (const u_char *) __THROW;
 u_long		ns_get32 (const u_char *) __THROW;
 void		ns_put16 (u_int, u_char *) __THROW;
diff --git a/libc/inet/Makefile.in b/libc/inet/Makefile.in
index 6c2c576..f2a495a 100644
--- a/libc/inet/Makefile.in
+++ b/libc/inet/Makefile.in
@@ -41,7 +41,7 @@ CSRC-$(findstring y,$(UCLIBC_HAS_IPV4)$(UCLIBC_HAS_IPV6)) += \
 	res_init.c res_query.c res_comp.c ns_name.c \
 	_res_state.c
 CSRC-$(findstring y,$(UCLIBC_HAS_RESOLVER_SUPPORT)) += \
-	ns_netint.c
+	ns_netint.c ns_parse.c
 ## # unused ATM
 ## CSRC-y += encodep.c decodep.c formquery.c
 
diff --git a/libc/inet/ns_parse.c b/libc/inet/ns_parse.c
new file mode 100644
index 0000000..e7aecb4
--- /dev/null
+++ b/libc/inet/ns_parse.c
@@ -0,0 +1,8 @@
+/*
+ * Copyright (C) 2000-2006 Erik Andersen <andersen at uclibc.org>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#define L_ns_parse
+#include RESOLVER
diff --git a/libc/inet/resolv.c b/libc/inet/resolv.c
index 6bfe52c..011cd5e 100644
--- a/libc/inet/resolv.c
+++ b/libc/inet/resolv.c
@@ -3886,6 +3886,201 @@ void ns_put32(unsigned long src, unsigned char *dst)
 }
 #endif /* L_ns_netint */
 
+#ifdef L_ns_parse
+/* These need to be in the same order as the nres.h:ns_flag enum. */
+const struct _ns_flagdata _ns_flagdata[16] = {
+	{ 0x8000, 15 },         /*%< qr. */
+	{ 0x7800, 11 },         /*%< opcode. */
+	{ 0x0400, 10 },         /*%< aa. */
+	{ 0x0200, 9 },          /*%< tc. */
+	{ 0x0100, 8 },          /*%< rd. */
+	{ 0x0080, 7 },          /*%< ra. */
+	{ 0x0040, 6 },          /*%< z. */
+	{ 0x0020, 5 },          /*%< ad. */
+	{ 0x0010, 4 },          /*%< cd. */
+	{ 0x000f, 0 },          /*%< rcode. */
+	{ 0x0000, 0 },          /*%< expansion (1/6). */
+	{ 0x0000, 0 },          /*%< expansion (2/6). */
+	{ 0x0000, 0 },          /*%< expansion (3/6). */
+	{ 0x0000, 0 },          /*%< expansion (4/6). */
+	{ 0x0000, 0 },          /*%< expansion (5/6). */
+	{ 0x0000, 0 },          /*%< expansion (6/6). */
+};
+
+static void setsection(ns_msg *msg, ns_sect sect)
+{
+	msg->_sect = sect;
+	if (sect == ns_s_max) {
+		msg->_rrnum = -1;
+		msg->_ptr = NULL;
+	} else {
+		msg->_rrnum = 0;
+		msg->_ptr = msg->_sections[(int)sect];
+	}
+}
+
+int ns_skiprr(const unsigned char *ptr,
+			  const unsigned char *eom,
+			  ns_sect section, int count)
+{
+	const u_char *optr = ptr;
+
+	for (; count > 0; count--) {
+		int b, rdlength;
+
+		b = dn_skipname(ptr, eom);
+		if (b < 0) {
+			errno = EMSGSIZE;
+			return -1;
+		}
+
+		ptr += b/*Name*/ + NS_INT16SZ/*Type*/ + NS_INT16SZ/*Class*/;
+		if (section != ns_s_qd) {
+			if (ptr + NS_INT32SZ + NS_INT16SZ > eom) {
+				errno = EMSGSIZE;
+				return -1;
+			}
+
+			ptr += NS_INT32SZ/*TTL*/;
+			NS_GET16(rdlength, ptr);
+			ptr += rdlength/*RData*/;
+		}
+	}
+
+	if (ptr > eom) {
+		errno = EMSGSIZE;
+		return -1;
+	}
+
+	return ptr - optr;
+}
+
+int
+ns_initparse(const unsigned char *msg, int msglen, ns_msg *handle)
+{
+	const u_char *eom = msg + msglen;
+	int i;
+
+	handle->_msg = msg;
+	handle->_eom = eom;
+	if (msg + NS_INT16SZ > eom) {
+		errno = EMSGSIZE;
+		return -1;
+	}
+
+	NS_GET16(handle->_id, msg);
+	if (msg + NS_INT16SZ > eom) {
+		errno = EMSGSIZE;
+		return -1;
+	}
+
+	NS_GET16(handle->_flags, msg);
+	for (i = 0; i < ns_s_max; i++) {
+		if (msg + NS_INT16SZ > eom) {
+			errno = EMSGSIZE;
+			return -1;
+		}
+
+		NS_GET16(handle->_counts[i], msg);
+	}
+	for (i = 0; i < ns_s_max; i++)
+		if (handle->_counts[i] == 0)
+			handle->_sections[i] = NULL;
+		else {
+			int b = ns_skiprr(msg, eom, (ns_sect)i,
+					  handle->_counts[i]);
+
+			if (b < 0)
+				return -1;
+			handle->_sections[i] = msg;
+			msg += b;
+		}
+
+	if (msg != eom) {
+		errno = EMSGSIZE;
+		return -1;
+	}
+
+	setsection(handle, ns_s_max);
+	return 0;
+}
+
+int
+ns_parserr(ns_msg *handle, ns_sect section, int rrnum, ns_rr *rr)
+{
+	int b;
+	int tmp;
+
+	/* Make section right. */
+	tmp = section;
+	if (tmp < 0 || section >= ns_s_max) {
+		errno = ENODEV;
+		return -1;
+	}
+
+	if (section != handle->_sect)
+		setsection(handle, section);
+
+	/* Make rrnum right. */
+	if (rrnum == -1)
+		rrnum = handle->_rrnum;
+	if (rrnum < 0 || rrnum >= handle->_counts[(int)section]) {
+		errno = ENODEV;
+		return -1;
+	}
+	if (rrnum < handle->_rrnum)
+		setsection(handle, section);
+	if (rrnum > handle->_rrnum) {
+		b = ns_skiprr(handle->_ptr, handle->_eom, section,
+			      rrnum - handle->_rrnum);
+
+		if (b < 0)
+			return (-1);
+		handle->_ptr += b;
+		handle->_rrnum = rrnum;
+	}
+
+	/* Do the parse. */
+	b = dn_expand(handle->_msg, handle->_eom,
+		      handle->_ptr, rr->name, NS_MAXDNAME);
+	if (b < 0)
+		return (-1);
+	handle->_ptr += b;
+	if (handle->_ptr + NS_INT16SZ + NS_INT16SZ > handle->_eom) {
+		errno = EMSGSIZE;
+		return -1;
+	}
+	NS_GET16(rr->type, handle->_ptr);
+	NS_GET16(rr->rr_class, handle->_ptr);
+	if (section == ns_s_qd) {
+		rr->ttl = 0;
+		rr->rdlength = 0;
+		rr->rdata = NULL;
+	} else {
+		if (handle->_ptr + NS_INT32SZ + NS_INT16SZ > handle->_eom) {
+			errno = EMSGSIZE;
+			return -1;
+		}
+		NS_GET32(rr->ttl, handle->_ptr);
+		NS_GET16(rr->rdlength, handle->_ptr);
+		if (handle->_ptr + rr->rdlength > handle->_eom) {
+			errno = EMSGSIZE;
+			return -1;
+		}
+		rr->rdata = handle->_ptr;
+		handle->_ptr += rr->rdlength;
+	}
+	if (++handle->_rrnum > handle->_counts[(int)section])
+		setsection(handle, (ns_sect)((int)section + 1));
+
+	return 0;
+}
+
+int ns_msg_getflag(ns_msg handle, int flag) {
+	return ((handle)._flags & _ns_flagdata[flag].mask) >> _ns_flagdata[flag].shift;
+}
+#endif /* L_ns_parse */
+
 /* Unimplemented: */
 /* res_mkquery */
 /* res_send */
diff --git a/include/resolv.h b/include/resolv.h
index 6556365..96ad4ab 100644
--- a/include/resolv.h
+++ b/include/resolv.h
@@ -292,8 +292,8 @@ __END_DECLS
 #define res_init		__res_init
 #if 0
 #define res_isourserver		__res_isourserver
-#define res_mkquery		__res_mkquery
 #endif
+#define res_mkquery		__res_mkquery
 #define res_query		__res_query
 #define res_querydomain		__res_querydomain
 #define res_search		__res_search
@@ -315,9 +315,9 @@ int		res_init (void) __THROW;
 libc_hidden_proto(res_init)
 #if 0
 int		res_isourserver (const struct sockaddr_in *) __THROW;
+#endif
 int		res_mkquery (int, const char *, int, int, const u_char *,
 			     int, const u_char *, u_char *, int) __THROW;
-#endif
 int		res_query (const char *, int, int, u_char *, int) __THROW;
 libc_hidden_proto(res_query)
 int		res_querydomain (const char *, const char *, int, int,
diff --git a/libc/inet/Makefile.in b/libc/inet/Makefile.in
index f2a495a..09ba65d 100644
--- a/libc/inet/Makefile.in
+++ b/libc/inet/Makefile.in
@@ -41,7 +41,7 @@ CSRC-$(findstring y,$(UCLIBC_HAS_IPV4)$(UCLIBC_HAS_IPV6)) += \
 	res_init.c res_query.c res_comp.c ns_name.c \
 	_res_state.c
 CSRC-$(findstring y,$(UCLIBC_HAS_RESOLVER_SUPPORT)) += \
-	ns_netint.c ns_parse.c
+	ns_netint.c ns_parse.c res_data.c
 ## # unused ATM
 ## CSRC-y += encodep.c decodep.c formquery.c
 
diff --git a/libc/inet/res_data.c b/libc/inet/res_data.c
new file mode 100644
index 0000000..b554b93
--- /dev/null
+++ b/libc/inet/res_data.c
@@ -0,0 +1,8 @@
+/*
+ * Copyright (C) 2000-2006 Erik Andersen <andersen at uclibc.org>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#define L_res_data
+#include RESOLVER
diff --git a/libc/inet/resolv.c b/libc/inet/resolv.c
index 011cd5e..627423b 100644
--- a/libc/inet/resolv.c
+++ b/libc/inet/resolv.c
@@ -4081,6 +4081,120 @@ int ns_msg_getflag(ns_msg handle, int flag) {
 }
 #endif /* L_ns_parse */
 
+#ifdef L_res_data
+int res_mkquery(int op, const char *dname, int class, int type,
+				const unsigned char *data, int datalen,
+				const unsigned char *newrr_in,
+				unsigned char *buf, int buflen)
+{
+	HEADER *hp;
+	unsigned char *cp, *ep;
+	unsigned char *dnptrs[20], **dpp, **lastdnptr;
+	uint32_t _res_options;
+	int n;
+
+	if (!buf || buflen < HFIXEDSZ) {
+		h_errno = NETDB_INTERNAL;
+		return -1;
+	}
+
+ again:
+	__UCLIBC_MUTEX_LOCK(__resolv_lock);
+	_res_options = _res.options;
+	__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
+	if (!(_res_options & RES_INIT)) {
+		res_init(); /* our res_init never fails */
+		goto again;
+	}
+
+#ifdef DEBUG
+	if (_res_options & RES_DEBUG)
+		printf(";; res_mkquery(%d, %s, %s, %d, %d)\n",
+			   name, (op, dname ? dname : "<Nil>"), class, type);
+#endif
+
+	memset(buf, 0, HFIXEDSZ);
+	hp = (HEADER *) buf;
+	hp->id = getpid() & 0xffff;
+	hp->opcode = op;
+	hp->rd = (_res.options & RES_RECURSE) != 0U;
+	hp->rcode = NOERROR;
+
+	cp = buf + HFIXEDSZ;
+	ep = buf + buflen;
+	dpp = dnptrs;
+	*dpp++ = buf;
+	*dpp++ = NULL;
+	lastdnptr = dnptrs + sizeof dnptrs / sizeof dnptrs[0];
+
+	/*
+	 * perform opcode specific processing
+	 */
+	switch (op) {
+	case QUERY:
+	case NS_NOTIFY_OP:
+		if (ep - cp < QFIXEDSZ)
+			return -1;
+
+		if ((n = dn_comp(dname, cp, ep - cp - QFIXEDSZ, dnptrs, lastdnptr)) < 0)
+			return -1;
+
+		cp += n;
+		NS_PUT16(type, cp);
+		NS_PUT16(class, cp);
+		hp->qdcount = htons(1);
+
+		if (op == QUERY || data == NULL)
+			break;
+
+		/*
+		 * Make an additional record for completion domain.
+		 */
+		if ((ep - cp) < RRFIXEDSZ)
+			return -1;
+
+		n = dn_comp((const char *)data, cp, ep - cp - RRFIXEDSZ,
+					 dnptrs, lastdnptr);
+		if (n < 0)
+			return -1;
+
+		cp += n;
+		NS_PUT16(T_NULL, cp);
+		NS_PUT16(class, cp);
+		NS_PUT32(0, cp);
+		NS_PUT16(0, cp);
+		hp->arcount = htons(1);
+
+		break;
+
+	case IQUERY:
+		/*
+		 * Initialize answer section
+		 */
+		if (ep - cp < 1 + RRFIXEDSZ + datalen)
+			return -1;
+
+		*cp++ = '\0';   /*%< no domain name */
+		NS_PUT16(type, cp);
+		NS_PUT16(class, cp);
+		NS_PUT32(0, cp);
+		NS_PUT16(datalen, cp);
+
+		if (datalen) {
+			memcpy(cp, data, (size_t)datalen);
+			cp += datalen;
+		}
+
+		hp->ancount = htons(1);
+		break;
+
+	default:
+		return -1;
+	}
+
+	return cp - buf;
+}
+#endif /* L_res_data */
+
 /* Unimplemented: */
-/* res_mkquery */
 /* res_send */
diff --git a/libc/inet/Makefile.in b/libc/inet/Makefile.in
index 09ba65d..a4d3c49 100644
--- a/libc/inet/Makefile.in
+++ b/libc/inet/Makefile.in
@@ -37,11 +37,10 @@ CSRC-$(findstring y,$(UCLIBC_HAS_IPV4)$(UCLIBC_HAS_IPV6)) += \
 	get_hosts_byaddr_r.c get_hosts_byname_r.c \
 	gethostbyaddr_r.c gethostbyname_r.c gethostbyname2_r.c \
 	gethostbyaddr.c gethostbyname.c gethostbyname2.c
-CSRC-$(findstring y,$(UCLIBC_HAS_IPV4)$(UCLIBC_HAS_IPV6)) += \
+CSRC-$(findstring y,$(UCLIBC_HAS_RESOLVER_SUPPORT)) += \
+	ns_netint.c ns_parse.c res_data.c \
 	res_init.c res_query.c res_comp.c ns_name.c \
 	_res_state.c
-CSRC-$(findstring y,$(UCLIBC_HAS_RESOLVER_SUPPORT)) += \
-	ns_netint.c ns_parse.c res_data.c
 ## # unused ATM
 ## CSRC-y += encodep.c decodep.c formquery.c
 
